# í¼ì…‰íŠ¸ë¡  ì„ í˜• ë¶„ë¥˜ê¸°

- ë…¼ë¦¬ íšŒë¡œ ì—­í• ì„ ìˆ˜í–‰í•˜ëŠ” í¼ì…‰íŠ¸ë¡ 
    - ì‚¬ëŒì˜ ì‹ ê²½ê³„ : ë‰´ëŸ° - ì‹ ê²½ë§ - ì§€ëŠ¥
    - ë”¥ëŸ¬ë‹ : í¼ì…‰íŠ¸ë¡  - ì¸ê³µ ì‹ ê²½ë§ - ì¸ê³µì§€ëŠ¥

- AND, OR, NAND, NOR ë“± ë…¼ë¦¬íšŒë¡œëŠ” ì„ í˜• ë¶„ë¥˜ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.(ì‹±ê¸€ ë ˆì´ì–´ í¼ì…‰íŠ¸ë¡ ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.)
- ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ (Single Layer Perceptron)
    - Input Layerì—ì„œ Output Layerë¡œ ë°”ë¡œ ê²°ê³¼ë¥¼ ë„ì¶œí•  ìˆ˜ ìˆë‹¤.(ì€ë‹‰ì¸µì´ ì—†ë‹¤) == Linear Classfier

## ë…¼ë¦¬ íšŒë¡œì˜ ì •ì˜

> ì¼ì •í•œ ë…¼ë¦¬ ì—°ì‚°ì— ì˜í•´ ì¶œë ¥ì„ ì–»ëŠ” íšŒë¡œë¥¼ ì˜ë¯¸

1. AND gate

| A/B | C |
|:---:|:---:|
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| **ğŸ/ğŸ** | **1** |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(1 âˆ— ğ´ + 1 âˆ— ğµ âˆ’ 1.5)`


2. OR gate

| A/B | C |
|:---:|:---:|
| **ğŸ/ğŸ** | **0** |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(1 âˆ— ğ´ + 1 âˆ— ğµ âˆ’ 0.5)`

3. NAND gate

| A/B | C |
|:---:|:---:|
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| **ğŸ/ğŸ** | **0** |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›((âˆ’1) âˆ— ğ´ + (âˆ’1) âˆ— ğµ + 1.5)`

4. NOR gate

| A/B | C |
|:---:|:---:|
| **ğŸ/ğŸ** | **1** |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›((âˆ’1) âˆ— ğ´ + (âˆ’1) âˆ— ğµ + 0.5)`

- ì…ë ¥ì¸µ(Input Layer) : ì™¸ë¶€ë¡œë¶€í„° ë°ì´í„°ë¥¼ ì…ë ¥ ë°›ëŠ” ì‹ ê²½ë§ ì…êµ¬ì˜ Layer
- ì¶œë ¥ì¸µ(Output Layer) : ëª¨ë¸ì˜ ìµœì¢… ì—°ì‚° ê²°ê³¼ë¥¼ ë‚´ë³´ë‚´ëŠ” ì‹ ê²½ë§ ì¶œêµ¬ì˜ Layer

### í¼ì…‰íŠ¸ë¡ ì„ í™œìš©í•œ ì„ í˜• ë¶„ë¥˜ê¸°

0, 1 ë°ì´í„°ë¥¼ ê³„ì‚°í•˜ë˜ í¼ì…‰íŠ¸ë¡  ë…¼ë¦¬ íšŒë¡œì—ì„œ í™•ì¥
- ì„ í˜• ë¶„ë¥˜ê¸°ë¡œì¨ ë°ì´í„° ë¶„ë¥˜ ê°€ëŠ¥ : 2ì°¨ì› ê³µê°„ì—ì„œ ê°•ì•„ì§€ì™€ ê³ ì–‘ì´ë¥¼ ë¶„ë¥˜

#### AND gateì™€ OR gate êµ¬í˜„

```
import numpy as np

'''
1. AND_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì…ë ¥ê°’ x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ëŠ”
           0.5, 0.5ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
           
   Step02. AND_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì„¤ì •í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ê°€ì§€ ê°’ì„ ëŒ€ì…í•´ë³´ë©°
           ì ì ˆí•œ Bias ê°’ì„ ì°¾ì•„ë³´ì„¸ìš”.
   
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           AND_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def AND_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([0.5,0.5])
    
    bias = -0.7
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)
    
'''
2. OR_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì…ë ¥ê°’ x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ëŠ”
           0.5, 0.5ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
           
   Step02. OR_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì„¤ì •í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ê°€ì§€ ê°’ì„ ëŒ€ì…í•´ë³´ë©°
           ì ì ˆí•œ Bias ê°’ì„ ì°¾ì•„ë³´ì„¸ìš”.
   
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           OR_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def OR_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([0.5,0.5])
    
    bias = -0.3
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)

'''
3. ì„¤ëª…ì„ ë³´ê³  Step Functionì„ ì™„ì„±í•©ë‹ˆë‹¤.

   Step01. 0 ë¯¸ë§Œì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 0ì„,
           0 ì´ìƒì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 1ì„
           ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.
'''
def Step_Function(y):
    
    return 1 if y >= 0 else 0
    
def main():
    
    # AND Gateì™€ OR Gateì— ë„£ì–´ì¤„ Input
    array = np.array([[0,0], [0,1], [1,0], [1,1]])
    
    # AND Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('AND Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ', Output: ',AND_gate(x1, x2))
    
    # OR Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('\nOR Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ', Output: ',OR_gate(x1, x2))

if __name__ == "__main__":
    main()
```

#### NAND gateì™€ NOR gate êµ¬í˜„

```
import numpy as np

'''
1. NAND_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì´ì „ ì‹¤ìŠµì„ ì°¸ê³ í•˜ì—¬ ì…ë ¥ê°’ x1ê³¼ x2ë¥¼
           Numpy array í˜•ì‹ìœ¼ë¡œ ì •ì˜í•œ í›„, x1ê³¼ x2ì—
           ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ë„ Numpy array í˜•ì‹ìœ¼ë¡œ 
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step02. NAND_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ê°€ì¤‘ ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           NAND_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def NAND_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([-0.5, -0.5])
    
    bias = 0.7
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)

'''
2. NOR_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ë§ˆì°¬ê°€ì§€ë¡œ ì…ë ¥ê°’ x1ê³¼ x2ë¥¼ Numpy array 
           í˜•ì‹ìœ¼ë¡œ ì •ì˜í•œ í›„, x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„
           ê°€ì¤‘ì¹˜ë„ Numpy array í˜•ì‹ìœ¼ë¡œ ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step02. NOR_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ê°€ì¤‘ ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           NOR_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def NOR_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([-0.5, -0.5])
    
    bias = 0.3
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y) 

'''
3. ì„¤ëª…ì„ ë³´ê³  Step Functionì„ ì™„ì„±í•©ë‹ˆë‹¤.
   ì• ì‹¤ìŠµì—ì„œ êµ¬í˜„í•œ í•¨ìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ 
   ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

   Step01. 0 ë¯¸ë§Œì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 0ì„,
           0 ì´ìƒì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 1ì„
           ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.
'''

def Step_Function(y):
    
    return 1 if y >=0 else 0  

def main():
    
    # NANDì™€ NOR Gateì— ë„£ì–´ì¤„ Input
    array = np.array([[0,0], [0,1], [1,0], [1,1]])
    
    # NAND Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('NAND Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ' Output: ',NAND_gate(x1, x2))
    
    # NOR Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('\nNOR Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ' Output: ',NOR_gate(x1, x2))

if __name__ == "__main__":
    main()
```


ğ´
ğµ
Confidential all right reserved
ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
04
í•˜ë‚˜ì˜ ì„ ìœ¼ë¡œ ë¶„ë¥˜í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œì˜ ë“±ì¥
04 ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
vs
ğ´
ğµ
ğ´
ğµ
?
ë¹„ì„ í˜•ì  ë…¼ë¦¬ ê²Œì´íŠ¸, XOR gate
04 ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
C
A
B
XOR gate A/B C
ğŸ/ğŸ 0
ğŸ/ğŸ 1
ğŸ/ğŸ 1
ğŸ/ğŸ 0
ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ ìœ¼ë¡œëŠ” í•´ê²° ë¶ˆê°€ëŠ¥í•œ XOR gate
04 ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
04 ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
1958
1969ë…„ ì²« ë²ˆì§¸ AI ê²¨ìš¸
1969
1986
1990 2020
ë¹„ì„ í˜•ì  ì ‘ê·¼ ë°©ë²•ì˜ í•„ìš”ì„±
04 ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ
Confidential all right reserved
ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
05
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
1958
1986ë…„ ì²« ë²ˆì§¸ ë¹™í•˜ê¸°ì˜ ë
1969
1986
1990 2020
ë¹„ì„ í˜•ì ì¸ ë¬¸ì œ í•´ê²°
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ ì€ ì…ë ¥ì¸µê³¼ ì¶œë ¥ì¸µë§Œ ì¡´ì¬
Input Layer Output Layer
ğ‘¥1
Î£
ğ‘¤1
ğ‘¤2
ğ‘ğ‘–ğ‘ğ‘ 
ğ‘¥1
ğ‘¥2 ğ‘¦
ğ‘¤0
ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ ì„ ì—¬ëŸ¬ ì¸µìœ¼ë¡œ ìŒ“ì•„ë³´ê¸°
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
Input Layer Output Layer
ğ‘¥1
Î£
ğ‘¤1
ğ‘¤2
ğ‘ğ‘–ğ‘ğ‘ 
?
ğ‘¥1
ğ‘¥2
ğ‘¤0
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
XOR ì—°ì‚°ì€ í•˜ë‚˜ì˜ ë ˆì´ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ í‘œí˜„í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥
í•˜ì§€ë§Œ, NANDì™€ OR ì—°ì‚°ì„ í•¨ê»˜ ì‚¬ìš©í•  ì‹œ í‘œí˜„ ê°€ëŠ¥
XOR gate ì˜ˆì‹œ
Input Layer Hidden Layer
ğ‘¥1
Î£
ğ‘¥1
ğ‘¥2
Output Layer
06 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ (Multi Layer Perceptron)
ì´ë ‡ê²Œ ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ ì„ ì—¬ëŸ¬ ê°œ ìŒ“ì€ ê²ƒì„
ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ (Multi Layer Perceptron)ì´ë¼ê³  ë¶€ë¦„
Input Layer Hidden Layer
ğ‘¥1
Î£
ğ‘¥1
ğ‘¥2
Output Layer
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
íˆë“ ì¸µ(Hidden Layer)
ì…ë ¥ì¸µê³¼ ì¶œë ¥ì¸µ ì‚¬ì´ì˜ ëª¨ë“  Layer
Input Layer Hidden Layer
ğ‘¥1
Î£
ğ‘¥1
ğ‘¥2
Output Layer
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
íˆë“ ì¸µì˜ ê°œìˆ˜ì™€ ë”¥ëŸ¬ë‹
íˆë“ ì¸µì´ 3ì¸µ ì´ìƒì¼ ì‹œ
ê¹Šì€ ì‹ ê²½ë§ì´ë¼ëŠ” ì˜ë¯¸ì˜ Deep Learning ë‹¨ì–´ ì‚¬ìš©
ğ‘¥1
ğ‘¥ğ‘›
â€¦
Input Layer
â€¦
1 Hidden Layer
â€¦
N Hidden Layer Input Layer
â€¦ â€¦
â€¦
05 ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ 
ë‹¤ì¸µ í¼ì…‰íŠ¸ë¡ ì´ ê²°ì •í•  ìˆ˜ ìˆëŠ” ì˜ì—­
1 Hidden Layer 2 Hidden Layers N Hidden Layers

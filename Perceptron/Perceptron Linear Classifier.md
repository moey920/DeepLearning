# í¼ì…‰íŠ¸ë¡  ì„ í˜• ë¶„ë¥˜ê¸°

- ë…¼ë¦¬ íšŒë¡œ ì—­í• ì„ ìˆ˜í–‰í•˜ëŠ” í¼ì…‰íŠ¸ë¡ 
    - ì‚¬ëŒì˜ ì‹ ê²½ê³„ : ë‰´ëŸ° - ì‹ ê²½ë§ - ì§€ëŠ¥
    - ë”¥ëŸ¬ë‹ : í¼ì…‰íŠ¸ë¡  - ì¸ê³µ ì‹ ê²½ë§ - ì¸ê³µì§€ëŠ¥

- AND, OR, NAND, NOR ë“± ë…¼ë¦¬íšŒë¡œëŠ” ì„ í˜• ë¶„ë¥˜ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.(ì‹±ê¸€ ë ˆì´ì–´ í¼ì…‰íŠ¸ë¡ ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.)
- ë‹¨ì¸µ í¼ì…‰íŠ¸ë¡ (Single Layer Perceptron)
    - Input Layerì—ì„œ Output Layerë¡œ ë°”ë¡œ ê²°ê³¼ë¥¼ ë„ì¶œí•  ìˆ˜ ìˆë‹¤.(ì€ë‹‰ì¸µì´ ì—†ë‹¤) == Linear Classfier

## ë…¼ë¦¬ íšŒë¡œì˜ ì •ì˜

> ì¼ì •í•œ ë…¼ë¦¬ ì—°ì‚°ì— ì˜í•´ ì¶œë ¥ì„ ì–»ëŠ” íšŒë¡œë¥¼ ì˜ë¯¸

1. AND gate

| A/B | C |
|:---:|:---:|
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| **ğŸ/ğŸ** | **1** |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(1 âˆ— ğ´ + 1 âˆ— ğµ âˆ’ 1.5)`


2. OR gate

| A/B | C |
|:---:|:---:|
| **ğŸ/ğŸ** | **0** |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›(1 âˆ— ğ´ + 1 âˆ— ğµ âˆ’ 0.5)`

3. NAND gate

| A/B | C |
|:---:|:---:|
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| ğŸ/ğŸ | 1 |
| **ğŸ/ğŸ** | **0** |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›((âˆ’1) âˆ— ğ´ + (âˆ’1) âˆ— ğµ + 1.5)`

4. NOR gate

| A/B | C |
|:---:|:---:|
| **ğŸ/ğŸ** | **1** |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |
| ğŸ/ğŸ | 0 |

`Ex) ğ¶ = ğ‘ğ‘ğ‘¡ğ‘–ğ‘£ğ‘ğ‘¡ğ‘–ğ‘œğ‘›((âˆ’1) âˆ— ğ´ + (âˆ’1) âˆ— ğµ + 0.5)`

- ì…ë ¥ì¸µ(Input Layer) : ì™¸ë¶€ë¡œë¶€í„° ë°ì´í„°ë¥¼ ì…ë ¥ ë°›ëŠ” ì‹ ê²½ë§ ì…êµ¬ì˜ Layer
- ì¶œë ¥ì¸µ(Output Layer) : ëª¨ë¸ì˜ ìµœì¢… ì—°ì‚° ê²°ê³¼ë¥¼ ë‚´ë³´ë‚´ëŠ” ì‹ ê²½ë§ ì¶œêµ¬ì˜ Layer

### í¼ì…‰íŠ¸ë¡ ì„ í™œìš©í•œ ì„ í˜• ë¶„ë¥˜ê¸°

0, 1 ë°ì´í„°ë¥¼ ê³„ì‚°í•˜ë˜ í¼ì…‰íŠ¸ë¡  ë…¼ë¦¬ íšŒë¡œì—ì„œ í™•ì¥
- ì„ í˜• ë¶„ë¥˜ê¸°ë¡œì¨ ë°ì´í„° ë¶„ë¥˜ ê°€ëŠ¥ : 2ì°¨ì› ê³µê°„ì—ì„œ ê°•ì•„ì§€ì™€ ê³ ì–‘ì´ë¥¼ ë¶„ë¥˜

#### AND gateì™€ OR gate êµ¬í˜„

```
import numpy as np

'''
1. AND_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì…ë ¥ê°’ x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ëŠ”
           0.5, 0.5ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
           
   Step02. AND_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì„¤ì •í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ê°€ì§€ ê°’ì„ ëŒ€ì…í•´ë³´ë©°
           ì ì ˆí•œ Bias ê°’ì„ ì°¾ì•„ë³´ì„¸ìš”.
   
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           AND_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def AND_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([0.5,0.5])
    
    bias = -0.7
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)
    
'''
2. OR_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì…ë ¥ê°’ x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ëŠ”
           0.5, 0.5ë¡œ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
           
   Step02. OR_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì„¤ì •í•©ë‹ˆë‹¤. ì—¬ëŸ¬ ê°€ì§€ ê°’ì„ ëŒ€ì…í•´ë³´ë©°
           ì ì ˆí•œ Bias ê°’ì„ ì°¾ì•„ë³´ì„¸ìš”.
   
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           OR_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def OR_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([0.5,0.5])
    
    bias = -0.3
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)

'''
3. ì„¤ëª…ì„ ë³´ê³  Step Functionì„ ì™„ì„±í•©ë‹ˆë‹¤.

   Step01. 0 ë¯¸ë§Œì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 0ì„,
           0 ì´ìƒì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 1ì„
           ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.
'''
def Step_Function(y):
    
    return 1 if y >= 0 else 0
    
def main():
    
    # AND Gateì™€ OR Gateì— ë„£ì–´ì¤„ Input
    array = np.array([[0,0], [0,1], [1,0], [1,1]])
    
    # AND Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('AND Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ', Output: ',AND_gate(x1, x2))
    
    # OR Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('\nOR Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ', Output: ',OR_gate(x1, x2))

if __name__ == "__main__":
    main()
```

#### NAND gateì™€ NOR gate êµ¬í˜„

```
import numpy as np

'''
1. NAND_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ì´ì „ ì‹¤ìŠµì„ ì°¸ê³ í•˜ì—¬ ì…ë ¥ê°’ x1ê³¼ x2ë¥¼
           Numpy array í˜•ì‹ìœ¼ë¡œ ì •ì˜í•œ í›„, x1ê³¼ x2ì—
           ê°ê° ê³±í•´ì¤„ ê°€ì¤‘ì¹˜ë„ Numpy array í˜•ì‹ìœ¼ë¡œ 
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step02. NAND_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ê°€ì¤‘ ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           NAND_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def NAND_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([-0.5, -0.5])
    
    bias = 0.7
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y)

'''
2. NOR_gate í•¨ìˆ˜ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

   Step01. ë§ˆì°¬ê°€ì§€ë¡œ ì…ë ¥ê°’ x1ê³¼ x2ë¥¼ Numpy array 
           í˜•ì‹ìœ¼ë¡œ ì •ì˜í•œ í›„, x1ê³¼ x2ì— ê°ê° ê³±í•´ì¤„
           ê°€ì¤‘ì¹˜ë„ Numpy array í˜•ì‹ìœ¼ë¡œ ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step02. NOR_gateë¥¼ ë§Œì¡±í•˜ëŠ” Bias ê°’ì„
           ì ì ˆíˆ ì„¤ì •í•´ì£¼ì„¸ìš”.
           
   Step03. ê°€ì¤‘ì¹˜, ì…ë ¥ê°’, Biasë¥¼ ì´ìš©í•˜ì—¬ 
           ê°€ì¤‘ ì‹ í˜¸ì˜ ì´í•©ì„ êµ¬í•©ë‹ˆë‹¤.
           
   Step04. Step Function í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ 
           NOR_gateì˜ ì¶œë ¥ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
'''

def NOR_gate(x1, x2):
    
    x = np.array([x1, x2])
    
    weight = np.array([-0.5, -0.5])
    
    bias = 0.3
    
    y = np.matmul(x, weight) + bias
    
    return Step_Function(y) 

'''
3. ì„¤ëª…ì„ ë³´ê³  Step Functionì„ ì™„ì„±í•©ë‹ˆë‹¤.
   ì• ì‹¤ìŠµì—ì„œ êµ¬í˜„í•œ í•¨ìˆ˜ë¥¼ ê·¸ëŒ€ë¡œ 
   ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

   Step01. 0 ë¯¸ë§Œì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 0ì„,
           0 ì´ìƒì˜ ê°’ì´ ë“¤ì–´ì˜¤ë©´ 1ì„
           ì¶œë ¥í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ë©´ ë©ë‹ˆë‹¤.
'''

def Step_Function(y):
    
    return 1 if y >=0 else 0  

def main():
    
    # NANDì™€ NOR Gateì— ë„£ì–´ì¤„ Input
    array = np.array([[0,0], [0,1], [1,0], [1,1]])
    
    # NAND Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('NAND Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ' Output: ',NAND_gate(x1, x2))
    
    # NOR Gateë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì¶œë ¥í•˜ì—¬ í™•ì¸
    print('\nNOR Gate ì¶œë ¥')
    
    for x1, x2 in array:
        print('Input: ',x1, x2, ' Output: ',NOR_gate(x1, x2))

if __name__ == "__main__":
    main()
```




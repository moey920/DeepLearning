# 과적합 문제(Overfitting)와 방지 기법

- 딥러닝 모델 학습에서의 과적합 방지 기법
    - 정규화(Regularization)
    - 드롭아웃(Dropout)
    - 배치 정규화(Batch Normalization)

- 모델이 복잡해질수록 parameter들은 많아지고, 절댓값이 커지는 경향이 발생함
    - x^1 + x^2 + .. + x^20 이라는 문제가 있다고 가정할 때, 계수가 0에 가까운 것은 학습하지 않는 방법으로 정규화한다. 이런 방법으로 과적합을 방지한다.(일반 식에서의 정규화) => w값이 0에 가까우면 0으로 만들어 모델에서 없앤다.(딥러닝 Regularization)
    - 기존 손실함수에 **규제항**을 더해 최적값 찾기 가능

## 과적합 문제와 방지 기법

- 정규화(Regularization)
    - L1 정규화(Lasso Regularization)
        - 가중치의 **절댓값**의 합을 규제항으로 정의 `∑(|W|)`
        - 작은 가중치들이 거의 0으로 수렴하여 몇 개의 중요한 가중치들만 남음

    - L2 정규화(Ridge Regularization)
        - 가중치의 **제곱의 합**을 규제항으로 정의 `∑(W^2)`
        - L1 정규화에 비하여 0으로 수렴하는 가중치가 적음
        - 큰 값을 가진 가중치를 더욱 제약하는 효과

    - 드롭아웃(DropOut)
        - 각 layer마다 **일정 비율의 뉴런을 임의로 drop**시켜 나머지 뉴런들만 학습하는 방법(모델의 복잡도를 내려 과적합 방지)
        - 드롭아웃을 적용하면 학습되는 노드와 가중치들이 매번 달라짐
        - 드롭아웃의 적용 방법
            - 다른 정규화 기법들과 상호 보완적으로 사용 가능(L1, L2와 같이 사용한다.)
            - drop된 뉴런은 backpropagation 때 신호를 차단
            - Test 때는 모든 뉴런에 신호를 전달
    - 배치 정규화(Batch Normalization)
        - Features의 range가 각각 다를 수 있다, (0~100, 0~1, -3~3 등)
            - 모델이 잘 학습되지 않는다. -> mean=0, var=1 등 정규화를 하면 학습이 더 잘된다.
        - Normalization을 처음 Input data 뿐만 아니라 신경망 내부 Hidden Layer의 input에도 적용
        - 배치 정규화의 장점
            - 매 Layer마다 정규화를 진행하므로 가중치 초기값에 크게 의존하지 않음(초기화 중요도 감소)
        - 과적합 억제(Dropout, L1,L2 정규화 필요성 감소)
        - 핵심은 **학습 속도의 향상**

### 과적합(Overfitting)

과적합(Overfitting)은 모델이 학습 데이터에만 너무 치중되어 학습 데이터에 대한 예측 성능은 좋으나 테스트 데이터에 대한 예측 성능이 떨어지는 경우를 말합니다.

모델이 과적합 되면 일반화되지 않은 모델이라고도 합니다. 과적합이 발생하는 원인은 아래와 같습니다.

- 데이터의 퍼진 정도, 즉 분산(variance)이 높은 경우
- 너무 많이 학습 데이터를 학습시킨 경우 (epochs가 매우 큰 경우)
- 학습에 사용된 파라미터가 너무 많은 경우
- 데이터에 비해 모델이 너무 복잡한 경우
- 데이터에 노이즈 & 이상치(outlier)가 너무 많은 경우

이번 실습에서는 일부러 과적합 된 모델을 만들어 보고 손실값(loss) 그래프를 통해 기존 모델과 어떻게 성능 차이가 나는지 확인해보겠습니다.

- 결과
```
scores_basic:  0.7481468
scores_overfit:  3.8213732
```

```
import numpy as np
import tensorflow as tf
from visual import *

import logging, os
logging.disable(logging.WARNING)
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' 

# 데이터를 전처리하는 함수

def sequences_shaping(sequences, dimension):
    
    results = np.zeros((len(sequences), dimension))
    for i, word_indices in enumerate(sequences):
        results[i, word_indices] = 1.0 
        
    return results
    
'''
1. 과적합 될 모델과 비교하기 위해 기본 모델을 
   마크다운 설명과 동일하게 생성합니다.
'''

def Basic(word_num):
    
    basic_model = tf.keras.Sequential([
        tf.keras.layers.Dense(256, activation = 'relu', input_shape=(word_num,)),
        tf.keras.layers.Dense(128, activation = 'relu'),
        tf.keras.layers.Dense(1, activation= 'sigmoid')
    ])
    
    return basic_model

'''
2. 기본 모델의 레이어 수와 노드 수를 자유롭게 늘려서
   과적합 될 모델을 생성합니다.
'''

def Overfitting(word_num):
    
    overfit_model = tf.keras.Sequential([
        tf.keras.layers.Dense(1024, activation = 'relu', input_shape=(word_num,)),
        tf.keras.layers.Dense(512, activation = 'relu'),
        tf.keras.layers.Dense(128, activation = 'relu'),
        tf.keras.layers.Dense(64, activation = 'relu'),
        tf.keras.layers.Dense(64, activation = 'relu'),
        tf.keras.layers.Dense(1, activation= 'sigmoid')
    ])
    
    return overfit_model

'''
3. 두 개의 모델을 불러온 후 학습시키고 테스트 데이터에 대해 평가합니다.

   Step01. basic_model와 overfit_model 함수를 이용해 
           두 모델을 불러옵니다.
   
   Step02. 두 모델의 손실 함수, 최적화 알고리즘, 
           평가 방법을 설정합니다.
   
   Step03. 두 모델의 구조를 확인하는 코드를 작성합니다.
   
   Step04. 두 모델을 학습시킵니다. 
           검증용 데이터도 설정해주세요.
           
           기본 모델은 'epochs'를 20, 
           과적합 모델은 'epochs'를 300이상으로 설정합니다.
           'batch_size'는 두 모델 모두 500으로 설정합니다.
   
   Step05. 두 모델을 테스트하고 
           binary crossentropy 값을 출력합니다. 
'''

def main():
    
    word_num = 100
    data_num = 25000
    
    # Keras에 내장되어 있는 imdb 데이터 세트를 불러오고 전처리합니다.
    
    (train_data, train_labels), (test_data, test_labels) = tf.keras.datasets.imdb.load_data(num_words = word_num)
    
    train_data = sequences_shaping(train_data, dimension = word_num)
    test_data = sequences_shaping(test_data, dimension = word_num)
    
    basic_model = Basic(word_num)    # 기본 모델입니다.
    overfit_model = Overfitting(word_num)  # 과적합시킬 모델입니다.
    
    basic_model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy', 'binary_crossentropy'])
    overfit_model.compile(loss = 'binary_crossentropy', optimizer = 'adam', metrics = ['accuracy', 'binary_crossentropy'])
    
    basic_history = basic_model.fit(train_data, train_labels, epochs = 20, batch_size = 500, validation_data = (test_data, test_labels))
    print('\n')
    overfit_history = overfit_model.fit(train_data, train_labels, epochs = 150, batch_size = 1000, validation_data = (test_data, test_labels))
    
    scores_basic = basic_model.evaluate(test_data, test_labels)
    scores_overfit = overfit_model.evaluate(test_data, test_labels)
    
    print('\nscores_basic: ', scores_basic[-1])
    print('scores_overfit: ', scores_overfit[-1])
    
    Visulaize([('Basic', basic_history),('Overfitting', overfit_history)])
    
    return basic_history, overfit_history

if __name__ == "__main__":
    main()
```
